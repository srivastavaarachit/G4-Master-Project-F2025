% WALL FOLLOWING - COLLISION AVOIDANCE AT <15cm
global key;
InitKeyboard();
fprintf("=== Navigation Starting NOW! ===\n");
fprintf("Press 'q' to quit\n\n");
brick.SetColorMode(1, 2);
should_quit = false;
target_distance = 7;       % Normal target: 2-3 inches
DANGER_DISTANCE = 15;      % SAFETY THRESHOLD: turn right if closer!
color_cooldown = 0;
loop_count = 0;

% MOTOR SPEEDS
LEFT_BASE  = 75;
RIGHT_BASE = 72;
WALL_GAIN  = 0.30;

fprintf("GO! Normal target: %d cm | Danger threshold: %d cm\n\n", target_distance, DANGER_DISTANCE);

while ~should_quit
    pause(0.08);
    loop_count = loop_count + 1;
    
    if key == 'q'
        fprintf("\n=== Quitting ===\n");
        brick.StopAllMotors('Brake');
        break;
    end
    
    % === READ SENSORS ===
    touch_pressed = brick.TouchPressed(4);
    distance = brick.UltrasonicDist(2);    % LEFT WALL DISTANCE
    color = brick.ColorCode(1);
    
    % Handle bad ultrasonic readings
    if isnan(distance) || distance <= 0
        distance = target_distance;
    end
    
    % Show distance every 25 loops
    if mod(loop_count, 25) == 0
        fprintf("Distance: %.1f cm", distance);
        if distance < DANGER_DISTANCE
            fprintf(" [TOO CLOSE - AVOIDING!]");
        end
        fprintf("\n");
    end
    
    if color_cooldown > 0
        color_cooldown = color_cooldown - 1;
    end
    
    % === COLLISION - 90° TURN ===
    if touch_pressed == 1
        fprintf("\n>>> COLLISION! <<<\n");
        brick.StopAllMotors('Brake');
        pause(0.5);
        
        % Back up
        brick.MoveMotor('A', -50);
        brick.MoveMotor('B', -50);
        pause(1.0);
        brick.StopAllMotors('Brake');
        pause(0.2);
        
        % 90-degree LEFT turn
        brick.MoveMotor('A', 55);
        brick.MoveMotor('B', -55);
        pause(0.35);
        brick.StopAllMotors('Brake');
        pause(0.3);
        
        color_cooldown = 15;
        continue;
    end
    
    % === COLOR - RED ===
    if color_cooldown == 0 && color == 5
        fprintf("\n>>> RED DETECTED <<<\n");
        brick.StopAllMotors('Brake');
        brick.beep();
        pause(0.5);
        fprintf("Resuming\n\n");
        color_cooldown = 20;
        continue;
    end
    
    % === COLOR - BLUE ===
    if color_cooldown == 0 && color == 2
        fprintf("\n>>> BLUE DETECTED <<<\n");
        brick.StopAllMotors('Brake');
        brick.beep();
        pause(0.3);
        brick.beep();
        pause(0.3);
        brick.beep();
        pause(0.5);
        fprintf("Resuming\n\n");
        color_cooldown = 20;
        continue;
    end
    
    % === WALL FOLLOWING WITH COLLISION AVOIDANCE ===
    
    % DANGER ZONE: Too close to wall (<15cm) - STEER RIGHT!
    if distance < DANGER_DISTANCE && distance > 0
        % AGGRESSIVE right turn to avoid collision
        left_speed = 80;      % Left motor FASTER
        right_speed = 50;     # Right motor SLOWER → turns RIGHT
        fprintf("⚠️ DANGER: %.1f cm - Steering RIGHT!\n", distance);
    else
        % NORMAL PROPORTIONAL CONTROL
        error = distance - target_distance;
        
        % Clamp error
        if error > 15
            error = 15;
        elseif error < -15
            error = -15;
        end
        
        adjustment = error * WALL_GAIN;
        
        % Too far → turn LEFT, Too close → turn RIGHT
        left_speed  = LEFT_BASE  - adjustment;
        right_speed = RIGHT_BASE + adjustment;
        
        % Speed limits
        if left_speed > 85
            left_speed = 85;
        elseif left_speed < 55
            left_speed = 55;
        end
        
        if right_speed > 85
            right_speed = 85;
        elseif right_speed < 55
            right_speed = 55;
        end
    end
    
    % DRIVE
    brick.MoveMotor('A', left_speed);
    brick.MoveMotor('B', right_speed);
    
end
CloseKeyboard();
fprintf("\n=== Done ===\n");
